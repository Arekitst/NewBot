import logging
import random
from datetime import datetime
import os
import json
import asyncio

import aiosqlite
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command, CommandObject, or_f
from aiogram.types import CallbackQuery, Message, LabeledPrice, PreCheckoutQuery
from aiogram.enums import ChatMemberStatus
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
logger = logging.getLogger(__name__)

# --- –ù–ê–°–¢–†–û–ô–ö–ò –ë–û–¢–ê ---
BOT_TOKEN = os.getenv("BOT_TOKEN", "7873522119:AAHWIa4R2MrexWmEi_wfUexTKtKB4GsxpXw")
DB_PATH = "bot.db"
ADMIN_IDS = [6179115044, 7189733067] # <-- –ù–ï –ó–ê–ë–£–î–¨–¢–ï –î–û–ë–ê–í–ò–¢–¨ –°–í–û–ô ID

# --- –ù–ê–°–¢–†–û–ô–ö–ò –ò–ì–†–û–í–û–ô –õ–û–ì–ò–ö–ò ---
MAX_PETS = 20 # <-- –ù–û–í–û–ï: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏—Ç–æ–º—Ü–µ–≤
QUIZ_COOLDOWN_HOURS = 5
MARRIAGE_MIN_LEVEL = 35
PET_MIN_LEVEL = 55 # –£—Ä–æ–≤–µ–Ω—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –≤—ã–ª—É–ø–ª–µ–Ω–∏—é —è–∏—Ü
MARRIAGE_COST = 250
PET_DEATH_DAYS = 2

PET_ACTIONS_COST = {
    "feed": 1,
    "grow": 5,
    "water": 2,
    "walk": 3,
}

# --- –ù–ê–°–¢–†–û–ô–ö–ê –Ø–ò–¶ –ò –í–ò–î–û–í –ü–ò–¢–û–ú–¶–ï–í ---
EGGS = {
    "common": {"name": "ü•ö –û–±—ã—á–Ω–æ–µ —è–π—Ü–æ", "cost": 150, "rarity": "common"},
    "rare": {"name": "üíé –†–µ–¥–∫–æ–µ —è–π—Ü–æ", "cost": 500, "rarity": "rare"},
    "legendary": {"name": "‚öúÔ∏è –õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–µ —è–π—Ü–æ", "cost": 1500, "rarity": "legendary"},
    "mythic": {"name": "‚ú® –ú–∏—Ñ–∏—á–µ—Å–∫–æ–µ —è–π—Ü–æ", "cost": 5000, "rarity": "mythic"},
}

PET_SPECIES = {
    "common": [
        {"species_name": "–ü–æ–ª–æ–∑", "images": {
            1: "https://i.ibb.co/4gRJSF4N/Gemini-Generated-Image-bbrjqrbbrjqrbbrj.png", 
            10: "https://i.ibb.co/x87LKPq2/image.png",
            35: "https://i.ibb.co/ccnTcgJX/image.png"}},
        {"species_name": "–£–∂", "images": {
            1: "https://i.ibb.co/qLBW0wN7/image.png", 
            10: "https://i.ibb.co/Z1fRyG8R/image.png",                              
            35: "https://i.ibb.co/Ng6pJ2wm/Gemini-Generated-Image-6z8b4s6z8b4s6z8b.png"}},
    ],
    "rare": [
        {"species_name": "–ì–∞–¥—é–∫–∞", "images": {
        1: "https://i.ibb.co/xSXPC1C7/image.png", 
            10: "https://i.ibb.co/Y4KqkSgt/image.png",
            35: "https://i.ibb.co/rRhY1nX3/image.png"}},
        {"species_name": "–≠—Ñ–∞", "images": {
        1: "https://i.ibb.co/TDnDKDJb/image.png", 
            10: "https://i.ibb.co/XfhfSP31/image.png",
            35: "https://i.ibb.co/prvbR5Kf/image.png"}},
    ],
    "legendary": [
        {"species_name": "–ü–∏—Ç–æ–Ω", "images": {
            1: "https://i.ibb.co/WCXKKBF/image.png", 
            10: "https://i.ibb.co/j9Q9XZTR/image.png",
            35: "https://i.ibb.co/qYjVcqck/Gemini-Generated-Image-aofhgzaofhgzaofh.png"}},
        {"species_name": "–ö–æ–±—Ä–∞", "images": {
            1: "https://i.ibb.co/DP5QFyJn/Gemini-Generated-Image-gzt9g3gzt9g3gzt9.png", 
            10: "https://i.ibb.co/HLS6vB21/Gemini-Generated-Image-m2l12m2l12m2l12m.png",
            35: "https://i.ibb.co/7xdG7Vmg/Gemini-Generated-Image-pcfv7cpcfv7cpcfv.png"}},
    ],
    "mythic": [
        {"species_name": "–í–∞—Å–∏–ª–∏—Å–∫", "images": {
            1: "https://i.ibb.co/0Rtx5sb1/Gemini-Generated-Image-rxh7a8rxh7a8rxh7.png",
            10: "https://i.ibb.co/RpBs3XxM/Gemini-Generated-Image-togzv2togzv2togz.png",
            35: "https://i.ibb.co/FLCVtdVg/Gemini-Generated-Image-bfub33bfub33bfub.png"}},
    ]
}

PING_MESSAGES = [ "—á–µ–º –∑–∞–Ω–∏–º–∞–µ—à—å—Å—è?", "–∑–∞—Ö–æ–¥–∏ –Ω–∞ –∏–≥—Ä—É?", "–∫–∞–∫ –Ω–∞—Å—á–µ—Ç –∫–∞—Ç–∫–∏?", "–≥–æ –æ–±—â–∞—Ç—å—Å—è!", "—Å–∫—É—á–Ω–æ, –¥–∞–≤–∞–π –ø–æ–≥–æ–≤–æ—Ä–∏–º?"]

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ —á–∞—Ç–∞—Ö
recent_users_activity = {}

# --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# --- FSM –°–û–°–¢–û–Ø–ù–ò–Ø ---
class TopupStates(StatesGroup):
    waiting_for_amount = State()

class QuizStates(StatesGroup):
    in_quiz = State()

class PetHatchStates(StatesGroup):
    waiting_for_name = State()

# --- –†–ê–ë–û–¢–ê –° –ë–ê–ó–û–ô –î–ê–ù–ù–´–• ---
async def init_db():
    async with aiosqlite.connect(DB_PATH) as conn:
        # ... (–∫–æ–¥ –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã users –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

        await conn.execute("""CREATE TABLE IF NOT EXISTS pets (
            pet_id INTEGER PRIMARY KEY AUTOINCREMENT, 
            owner_id INTEGER, 
            name TEXT,
            species TEXT, 
            pet_level INTEGER DEFAULT 1, 
            last_fed INTEGER DEFAULT 0,
            last_watered INTEGER DEFAULT 0, 
            last_grown INTEGER DEFAULT 0,
            last_walked INTEGER DEFAULT 0, 
            creation_date INTEGER
        )""")
        
        # –≠—Ç–æ—Ç –∫–æ–¥ –¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–∏ —Å—Ç–∞—Ä–æ–π —Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ —Å UNIQUE
        try:
            cursor = await conn.execute("PRAGMA index_list('pets')")
            indexes = await cursor.fetchall()
            unique_index_exists = any('unique' in str(idx).lower() and 'owner_id' in str(idx).lower() for idx in indexes)
            if unique_index_exists:
                logger.info("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å—Ç–∞—Ä–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–∞–±–ª–∏—Ü—ã 'pets'. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –º–∏–≥—Ä–∞—Ü–∏—è...")
                await conn.execute("CREATE TABLE pets_new AS SELECT * FROM pets")
                await conn.execute("DROP TABLE pets")
                await conn.execute("""CREATE TABLE pets (
                    pet_id INTEGER PRIMARY KEY AUTOINCREMENT, owner_id INTEGER, name TEXT,
                    species TEXT, pet_level INTEGER DEFAULT 1, last_fed INTEGER DEFAULT 0,
                    last_watered INTEGER DEFAULT 0, last_grown INTEGER DEFAULT 0,
                    last_walked INTEGER DEFAULT 0, creation_date INTEGER)""")
                await conn.execute("INSERT INTO pets SELECT * FROM pets_new")
                await conn.execute("DROP TABLE pets_new")
                logger.info("–ú–∏–≥—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã 'pets' –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∏–≥—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã pets: {e}")

        # ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –¥–ª—è user_eggs –∏ quiz_questions –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

async def populate_questions():
    questions = [
        ("–ö–∞–∫–∞—è –∑–º–µ—è —Å—á–∏—Ç–∞–µ—Ç—Å—è —Å–∞–º–æ–π —è–¥–æ–≤–∏—Ç–æ–π –≤ –º–∏—Ä–µ?", json.dumps(["–¢–∞–π–ø–∞–Ω", "–ß–µ—Ä–Ω–∞—è –º–∞–º–±–∞", "–ì–∞–¥—é–∫–∞", "–ö–æ–±—Ä–∞"]), "–¢–∞–π–ø–∞–Ω"),
        ("–ö–∞–∫–∞—è –∑–º–µ—è —Å–∞–º–∞—è –±–æ–ª—å—à–∞—è –≤ –º–∏—Ä–µ?", json.dumps(["–ê–Ω–∞–∫–æ–Ω–¥–∞", "–°–µ—Ç—á–∞—Ç—ã–π –ø–∏—Ç–æ–Ω", "–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –∫–æ–±—Ä–∞", "–¢–∏–≥—Ä–æ–≤—ã–π –ø–∏—Ç–æ–Ω"]), "–°–µ—Ç—á–∞—Ç—ã–π –ø–∏—Ç–æ–Ω"),
        ("–ï—Å—Ç—å –ª–∏ —É –∑–º–µ–π —É—à–∏?", json.dumps(["–î–∞, –Ω–æ –æ–Ω–∏ —Å–∫—Ä—ã—Ç—ã", "–¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É—Ö–æ", "–ù–µ—Ç", "–î–∞, –∫–∞–∫ —É —è—â–µ—Ä–∏—Ü"]), "–¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É—Ö–æ"),
        ("–ö–∞–∫–∞—è –∑–º–µ—è –æ—Ç–∫–ª–∞–¥—ã–≤–∞–µ—Ç —Å–∞–º—ã–µ –±–æ–ª—å—à–∏–µ —è–π—Ü–∞?", json.dumps(["–ü–∏—Ç–æ–Ω", "–ê–Ω–∞–∫–æ–Ω–¥–∞", "–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –∫–æ–±—Ä–∞", "–£–¥–∞–≤"]), "–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –∫–æ–±—Ä–∞"),
        ("–ß—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –∑–º–µ—è–º '–Ω—é—Ö–∞—Ç—å' —è–∑—ã–∫–æ–º?", json.dumps(["–û—Ä–≥–∞–Ω –Ø–∫–æ–±—Å–æ–Ω–∞", "–ù–æ–∑–¥—Ä–∏", "–¢–µ—Ä–º–æ—Ä–µ—Ü–µ–ø—Ç–æ—Ä—ã", "–ö–æ–Ω—á–∏–∫ —è–∑—ã–∫–∞"]), "–û—Ä–≥–∞–Ω –Ø–∫–æ–±—Å–æ–Ω–∞"),
        ("–ö–∞–∫ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–æ—Ü–µ—Å—Å —Å–±—Ä–∞—Å—ã–≤–∞–Ω–∏—è –∫–æ–∂–∏ —É –∑–º–µ–π?", json.dumps(["–õ–∏–Ω—å–∫–∞", "–ú–µ—Ç–∞–º–æ—Ä—Ñ–æ–∑–∞", "–†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è", "–ê–Ω–∞–±–∏–æ–∑"]), "–õ–∏–Ω—å–∫–∞"),
        ("–ö–∞–∫–∞—è –∑–º–µ—è —Å–ø–æ—Å–æ–±–Ω–∞ '–ø–ª–µ–≤–∞—Ç—å—Å—è' —è–¥–æ–º?", json.dumps(["–û—à–µ–π–Ω–∏–∫–æ–≤–∞—è –∫–æ–±—Ä–∞", "–ì–∞–¥—é–∫–∞ –†–∞—Å—Å–µ–ª–∞", "–ë—É—à–º–µ–π—Å—Ç–µ—Ä", "–≠—Ñ–∞"]), "–û—à–µ–π–Ω–∏–∫–æ–≤–∞—è –∫–æ–±—Ä–∞"),
        ("–°–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –≤–∏–¥–æ–≤ –∑–º–µ–π —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –º–∏—Ä–µ?", json.dumps(["–û–∫–æ–ª–æ 1000", "–û–∫–æ–ª–æ 2000", "–û–∫–æ–ª–æ 3500", "–ë–æ–ª–µ–µ 5000"]), "–û–∫–æ–ª–æ 3500"),
        ("–ö–∞–∫–∞—è –∏–∑ —ç—Ç–∏—Ö –∑–º–µ–π –Ω–µ —è–¥–æ–≤–∏—Ç–∞?", json.dumps(["–ú–æ–ª–æ—á–Ω–∞—è –∑–º–µ—è", "–ö–æ—Ä–∞–ª–ª–æ–≤—ã–π –∞—Å–ø–∏–¥", "–¢–∞–π–ø–∞–Ω", "–ú–æ—Ä—Å–∫–∞—è –∑–º–µ—è"]), "–ú–æ–ª–æ—á–Ω–∞—è –∑–º–µ—è"),
        ("–ö–∞–∫—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –º–æ–∂–µ—Ç —Ä–∞–∑–≤–∏—Ç—å –ß–µ—Ä–Ω–∞—è –º–∞–º–±–∞?", json.dumps(["–î–æ 5 –∫–º/—á", "–î–æ 10 –∫–º/—á", "–î–æ 20 –∫–º/—á", "–î–æ 30 –∫–º/—á"]), "–î–æ 20 –∫–º/—á"),
        ("–ß—Ç–æ –∏–∑ —ç—Ç–æ–≥–æ –ù–ï –µ–¥—è—Ç –∑–º–µ–∏?", json.dumps(["–ü—Ç–∏—Ü", "–Ø–π—Ü–∞", "–†—ã–±—É", "–¢—Ä–∞–≤—É"]), "–¢—Ä–∞–≤—É"),
        ("–ö–∞–∫–∞—è –∑–º–µ—è –∏–∑–≤–µ—Å—Ç–Ω–∞ —Å–≤–æ–∏–º '–∫–∞–ø—é—à–æ–Ω–æ–º'?", json.dumps(["–ö–æ–±—Ä–∞", "–ú–∞–º–±–∞", "–£–¥–∞–≤", "–ü–∏—Ç–æ–Ω"]), "–ö–æ–±—Ä–∞"),
    ]
    async with aiosqlite.connect(DB_PATH) as conn:
        cursor = await conn.execute("SELECT COUNT(*) FROM quiz_questions")
        count = (await cursor.fetchone())[0]
        if count == 0:
            await conn.executemany("INSERT INTO quiz_questions (question_text, options, correct_answer) VALUES (?, ?, ?)", questions)
            await conn.commit()
            logger.info(f"Added {len(questions)} initial questions to the database.")

async def db_execute(query, params=(), fetch=None):
    async with aiosqlite.connect(DB_PATH) as conn:
        conn.row_factory = aiosqlite.Row
        cursor = await conn.execute(query, params)
        if fetch == 'one':
            result = await cursor.fetchone()
        elif fetch == 'all':
            result = await cursor.fetchall()
        else:
            await conn.commit()
            result = None
        return result

async def get_user(user_id: int):
    return await db_execute("SELECT * FROM users WHERE user_id = ?", (user_id,), fetch='one')

async def add_user(user_id: int, username: str):
    await db_execute(
        "INSERT OR IGNORE INTO users (user_id, username, balance, level) VALUES (?, ?, 0, 0)",
        (user_id, username)
    )

async def update_user_field(user_id: int, field: str, value):
    await db_execute(f"UPDATE users SET {field} = ? WHERE user_id = ?", (value, user_id))

async def get_pet(owner_id: int):
    return await db_execute("SELECT * FROM pets WHERE owner_id = ?", (owner_id,), fetch='one')

async def create_pet(owner_id: int, name: str, species: str):
    now = int(datetime.now().timestamp())
    await db_execute("INSERT INTO pets (owner_id, name, species, last_fed, last_watered, last_grown, last_walked, creation_date) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                      (owner_id, name, species, now, now, now, now, now))

async def update_pet_field(owner_id: int, field: str, value):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è –ø–∏—Ç–æ–º—Ü–∞."""
    await db_execute(f"UPDATE pets SET {field} = ? WHERE owner_id = ?", (value, owner_id))

async def delete_pet(owner_id: int):
    await db_execute("DELETE FROM pets WHERE owner_id = ?", (owner_id,))

async def get_user_eggs(owner_id: int):
    return await db_execute("SELECT * FROM user_eggs WHERE owner_id = ?", (owner_id,), fetch='all')

async def add_user_egg(owner_id: int, egg_type: str):
    await db_execute("INSERT INTO user_eggs (owner_id, egg_type) VALUES (?, ?)", (owner_id, egg_type))

async def delete_user_egg(user_egg_id: int):
    await db_execute("DELETE FROM user_eggs WHERE user_egg_id = ?", (user_egg_id,))

async def get_random_question():
    return await db_execute("SELECT * FROM quiz_questions ORDER BY RANDOM() LIMIT 1", fetch='one')

async def get_user_mention_by_id(user_id: int) -> str:
    try:
        user = await bot.get_chat(user_id)
        return f'<a href="tg://user?id={user.id}">{user.full_name}</a>'
    except TelegramBadRequest:
        return f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (ID: {user_id})"
    except Exception as e:
        logger.error(f"Could not get user mention for {user_id}: {e}")
        return f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (ID: {user_id})"

async def check_items(user_id: int):
    user = await get_user(user_id)
    if not user: return
    now = int(datetime.now().timestamp())
    updates = {}
    if user["prefix_end"] != 0 and user["prefix_end"] < now: updates["prefix_end"] = 0
    if user["antitar_end"] != 0 and user["antitar_end"] < now: updates["antitar_end"] = 0
    if user["vip_end"] != 0 and user["vip_end"] < now: updates["vip_end"] = 0
    for field, value in updates.items(): await update_user_field(user_id, field, value)

async def check_pet_death(owner_id: int):
    pet = await get_pet(owner_id)
    if not pet:
        return True
    now_ts = int(datetime.now().timestamp())
    death_timestamp = now_ts - (PET_DEATH_DAYS * 24 * 3600)
    last_action_time = max(pet['last_fed'] or 0, pet['last_watered'] or 0, pet['last_walked'] or 0)
    
    if last_action_time > death_timestamp:
        return True

    await delete_pet(owner_id)
    try:
        await bot.send_message(owner_id, f"üíî –í–∞—à –ø–∏—Ç–æ–º–µ—Ü {pet['name']} ({pet['species']}) —É–º–µ—Ä –æ—Ç –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–∞ —É—Ö–æ–¥–∞...")
    except Exception as e:
        logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Å–º–µ—Ä—Ç–∏ –ø–∏—Ç–æ–º—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {owner_id}: {e}")
    return False

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î ---
@dp.message(or_f(Command("start", "help", "—Å—Ç–∞—Ä—Ç", "–ø–æ–º–æ—â—å"), F.text.lower().in_(['start', 'help', '—Å—Ç–∞—Ä—Ç', '–ø–æ–º–æ—â—å'])))
async def cmd_start(message: Message):
    try:
        user_id = message.from_user.id
        username = message.from_user.username or message.from_user.full_name
        await add_user(user_id, username)
        
        if message.chat.type == 'private':
            tutorial_text = (
                "üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ–º –≤ –∑–º–µ–∏–Ω–æ–º –±–æ—Ç–µ!\n\n"
                "**–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**\n"
                "‚ñ´Ô∏è `/profile` –∏–ª–∏ `–ø—Ä–æ—Ñ–∏–ª—å` ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å.\n"
                "‚ñ´Ô∏è `/hunt` –∏–ª–∏ `–æ—Ö–æ—Ç–∞` ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è –Ω–∞ –æ—Ö–æ—Ç—É.\n"
                "‚ñ´Ô∏è `/pay` –∏–ª–∏ `–ø–µ—Ä–µ–≤–æ–¥` (–≤ –æ—Ç–≤–µ—Ç) ‚Äî –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ —è—â–µ—Ä–æ–∫.\n"
                "‚ñ´Ô∏è `/shop` –∏–ª–∏ `–º–∞–≥–∞–∑–∏–Ω` ‚Äî –∫—É–ø–∏—Ç—å —É–ª—É—á—à–µ–Ω–∏—è.\n"
                "‚ñ´Ô∏è `/topup` –∏–ª–∏ `–ø–æ–ø–æ–ª–Ω–∏—Ç—å` ‚Äî –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å –∑–∞ Telegram ‚òÖ.\n\n"
                "**–ò–≥—Ä–æ–≤—ã–µ –º–µ—Ö–∞–Ω–∏–∫–∏:**\n"
                "üêç `/quiz` –∏–ª–∏ `–≤–∏–∫—Ç–æ—Ä–∏–Ω–∞` - –ø—Ä–æ–π—Ç–∏ –≤–∏–∫—Ç–æ—Ä–∏–Ω—É.\n"
                "üíñ `/marry` –∏–ª–∏ `–∂–µ–Ω–∏—Ç—å` (–≤ –æ—Ç–≤–µ—Ç) - —Å–¥–µ–ª–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n"
                "ü•ö `/eggshop` –∏–ª–∏ `–º–∞–≥–∞–∑–∏–Ω—è–∏—Ü` - –º–∞–≥–∞–∑–∏–Ω —è–∏—Ü.\n"
                "üß∫ `/myeggs` –∏–ª–∏ `–º–æ–∏—è–π—Ü–∞` - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ —è–π—Ü–∞.\n"
                "üêæ `/mypet` –∏–ª–∏ `–º–æ–π–ø–∏—Ç–æ–º–µ—Ü` - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∏—Ç–æ–º—Ü–µ–º.\n"
                "üìû `/ping` –∏–ª–∏ `–ø–∏–Ω–≥` - –ø–æ–∑–≤–∞—Ç—å –∏–≥—Ä–æ–∫–∞ –≤ —á–∞—Ç–µ.\n\n"
                "**–ö–æ–º–∞–Ω–¥—ã –æ—Ç–Ω–æ—à–µ–Ω–∏–π:**\n"
                "üíç `/accept` –∏–ª–∏ `–ø—Ä–∏–Ω—è—Ç—å` - –ø—Ä–∏–Ω—è—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.\n"
                "üíî `/divorce` –∏–ª–∏ `—Ä–∞–∑–≤–æ–¥` - —Ä–∞–∑–æ—Ä–≤–∞—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è."
            )
            await message.answer(tutorial_text)
        else:
            await message.answer("üêç –ó–º–µ–∏–Ω—ã–π –±–æ—Ç –∫ –≤–∞—à–∏–º —É—Å–ª—É–≥–∞–º! –ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥, –Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")

    except Exception as e:
        logger.exception(f"Error in start command: {e}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

@dp.message(or_f(Command("profile", "–ø—Ä–æ—Ñ–∏–ª—å"), F.text.lower().in_(['profile', '–ø—Ä–æ—Ñ–∏–ª—å'])))
async def cmd_profile(message: Message):
    try:
        target_user_msg = message.reply_to_message or message
        user_id = target_user_msg.from_user.id
        username = target_user_msg.from_user.username or target_user_msg.from_user.full_name

        # üîß –î–æ–±–∞–≤–∏–º —é–∑–µ—Ä–∞, –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        await add_user(user_id, username)
        user = await get_user(user_id)
        if not user:
            await message.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å.")
            return

        # üîß –ó–∞–ø–æ–ª–Ω–∏–º –Ω—É–ª—è–º–∏ –ø—É—Å—Ç—ã–µ –ø–æ–ª—è
        defaulted = {
            "balance": 0,
            "level": 0,
            "prefix_end": 0,
            "antitar_end": 0,
            "vip_end": 0,
            "partner_id": 0,
        }
        for key, default in defaulted.items():
            if user[key] is None:
                await update_user_field(user_id, key, default)

        await check_items(user_id)
        user = await get_user(user_id)  # –µ—â—ë —Ä–∞–∑ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π

        balance = user["balance"]
        level = user["level"]

        now = int(datetime.now().timestamp())
        def format_item(end_timestamp):
            if end_timestamp and end_timestamp > now:
                dt = datetime.fromtimestamp(end_timestamp)
                return f"–∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt.strftime('%d.%m.%Y %H:%M')}"
            return "–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"

        partner_status = "–≤ –∞–∫—Ç–∏–≤–Ω–æ–º –ø–æ–∏—Å–∫–µ"
        if user["partner_id"]:
            partner_name = await get_user_mention_by_id(user['partner_id'])
            partner_status = f"–≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö —Å {partner_name}"

        profile_title = "üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å" if user_id == message.from_user.id else f"üë§ –ü—Ä–æ—Ñ–∏–ª—å {target_user_msg.from_user.full_name}"

        text = (
            f"{profile_title}:\n"
            f"–£—Ä–æ–≤–µ–Ω—å: {level} üêç\n"
            f"–ë–∞–ª–∞–Ω—Å: {balance} ü¶é\n"
            f"–°—Ç–∞—Ç—É—Å: {partner_status}\n\n"
            f"–ü—Ä–µ—Ñ–∏–∫—Å: {format_item(user['prefix_end'])}\n"
            f"–ê–Ω—Ç–∏—Ç–∞—Ä: {format_item(user['antitar_end'])}\n"
            f"VIP: {format_item(user['vip_end'])}"
        )

        kb = InlineKeyboardBuilder()
        kb.add(types.InlineKeyboardButton(text="üêç –ü—Ä–æ–π—Ç–∏ –≤–∏–∫—Ç–æ—Ä–∏–Ω—É", callback_data="start_quiz"))
        kb.add(types.InlineKeyboardButton(text="üêæ –ú–æ–π –ø–∏—Ç–æ–º–µ—Ü", callback_data="my_pet_profile"))
        kb.add(types.InlineKeyboardButton(text="üõí –ú–∞–≥–∞–∑–∏–Ω", callback_data="shop_main"))
        kb.adjust(1)

        await message.answer(text, reply_markup=kb.as_markup(), parse_mode="HTML")
    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ /profile: {e}")
        await message.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è.")
@dp.message(or_f(Command("hunt", "–æ—Ö–æ—Ç–∞"), F.text.lower().in_(['hunt', '–æ—Ö–æ—Ç–∞'])))
async def cmd_hunt(message: Message):
    user_id = message.from_user.id
    await add_user(user_id, message.from_user.username or message.from_user.full_name)
    user = await get_user(user_id)
    now = int(datetime.now().timestamp())
    last_hunt = user["last_hunt"] or 0
    cooldown = 24 * 3600 
    if now - last_hunt < cooldown:
        remaining = cooldown - (now - last_hunt)
        hours, remainder = divmod(remaining, 3600)
        minutes, _ = divmod(remainder, 60)
        await message.answer(f"‚è≥ –û—Ö–æ—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ {int(hours)} —á {int(minutes)} –º–∏–Ω.")
        return
    catch = random.randint(1, 10)
    current_balance = user["balance"] or 0
    new_balance = current_balance + catch
    await update_user_field(user_id, "balance", new_balance)
    await update_user_field(user_id, "last_hunt", now)
    await message.answer(f"üéâ –í—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏—Å—å –Ω–∞ –æ—Ö–æ—Ç—É –∏ –ø–æ–π–º–∞–ª–∏ {catch} ü¶é!\n–í–∞—à –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} ü¶é")

@dp.message(or_f(Command("pay", "–ø–µ—Ä–µ–≤–æ–¥"), F.text.lower().startswith(('pay ', '–ø–µ—Ä–µ–≤–æ–¥ '))))
async def cmd_pay(message: Message, command: CommandObject = None):
    if message.chat.type == 'private':
        await message.answer("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –≥—Ä—É–ø–ø–µ, –æ—Ç–≤–µ—á–∞—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return

    if not message.reply_to_message or message.reply_to_message.from_user.is_bot or message.reply_to_message.from_user.id == message.from_user.id:
        await message.reply("‚ùóÔ∏è **–û—à–∏–±–∫–∞:**\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç—É –∫–æ–º–∞–Ω–¥—É –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return
    
    args = None
    if command:
        args = command.args
    else:
        parts = message.text.split(maxsplit=1)
        args = parts[1] if len(parts) > 1 else None

    if args is None:
        await message.reply("‚ùóÔ∏è **–û—à–∏–±–∫–∞:**\n–£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞. –ü—Ä–∏–º–µ—Ä: `–ø–µ—Ä–µ–≤–æ–¥ 50`")
        return

    try:
        amount = int(args)
        if amount <= 0:
            raise ValueError
    except (TypeError, ValueError):
        await message.reply("‚ùóÔ∏è **–û—à–∏–±–∫–∞:**\n–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã. –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ. –ü—Ä–∏–º–µ—Ä: `–ø–µ—Ä–µ–≤–æ–¥ 50`")
        return
        
    sender = message.from_user
    recipient = message.reply_to_message.from_user
        
    await add_user(sender.id, sender.username or sender.full_name)
    await add_user(recipient.id, recipient.username or recipient.full_name)
    sender_data = await get_user(sender.id)
    
    sender_balance = sender_data['balance'] or 0
    if sender_balance < amount:
        await message.reply(f"‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!**\n–£ –≤–∞—Å –Ω–∞ –±–∞–ª–∞–Ω—Å–µ –≤—Å–µ–≥–æ {sender_balance} ü¶é.")
        return
        
    recipient_data = await get_user(recipient.id)
    recipient_balance = recipient_data['balance'] or 0
    await update_user_field(sender.id, "balance", sender_balance - amount)
    await update_user_field(recipient.id, "balance", recipient_balance + amount)
    
    sender_mention = await get_user_mention_by_id(sender.id)
    recipient_mention = await get_user_mention_by_id(recipient.id)
    await message.answer(f"üí∏ **–ü–µ—Ä–µ–≤–æ–¥ —É—Å–ø–µ—à–µ–Ω!**\n\n{sender_mention} –ø–µ—Ä–µ–≤–µ–ª(–∞) {amount} ü¶é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {recipient_mention}.", parse_mode="HTML")

# --- –ê–î–ú–ò–ù-–ö–û–ú–ê–ù–î–´ ---
@dp.message(or_f(Command("give", "–≤—ã–¥–∞—Ç—å"), F.text.lower().startswith(('give ', '–≤—ã–¥–∞—Ç—å '))))
async def cmd_give(message: Message, command: CommandObject = None):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    args = command.args if command else (message.text.split(maxsplit=1)[1] if ' ' in message.text else None)

    if not args:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∞—Ä–≥—É–º–µ–Ω—Ç—ã.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `give <user_id> <amount>`")
        return
        
    try:
        arg_parts = args.split()
        if len(arg_parts) != 2: raise ValueError("–ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤")
        target_id, amount = int(arg_parts[0]), int(arg_parts[1])
        if amount <= 0: raise ValueError("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π")
    except ValueError:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `give <user_id> <—Å—É–º–º–∞>`")
        return
        
    target_user = await get_user(target_id)
    if not target_user:
        await add_user(target_id, f"User {target_id}")
        target_user = await get_user(target_id)

    current_balance = target_user["balance"] or 0
    new_balance = current_balance + amount
    await update_user_field(target_id, "balance", new_balance)
    await message.answer(f"‚úÖ –í—ã–¥–∞–ª–∏ {amount} ü¶é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID {target_id}. –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} ü¶é")

@dp.message(or_f(Command("take", "–∑–∞–±—Ä–∞—Ç—å"), F.text.lower().startswith(('take ', '–∑–∞–±—Ä–∞—Ç—å '))))
async def cmd_take(message: Message, command: CommandObject = None):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    args = command.args if command else (message.text.split(maxsplit=1)[1] if ' ' in message.text else None)

    if not args:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∞—Ä–≥—É–º–µ–Ω—Ç—ã.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `take <user_id> <amount|all>`")
        return

    try:
        arg_parts = args.split()
        if len(arg_parts) != 2: raise ValueError("–ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤")
        
        target_id = int(arg_parts[0])
        amount_str = arg_parts[1]

        target_user = await get_user(target_id)
        if not target_user:
            await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {target_id} –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        target_balance = target_user['balance'] or 0

        if amount_str.lower() == 'all':
            amount_to_take = target_balance
        elif amount_str.isdigit():
            amount_to_take = int(amount_str)
        else:
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã")

        if amount_to_take <= 0:
             raise ValueError("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π")

        if amount_to_take > target_balance:
            await message.answer(f"–ù–µ–ª—å–∑—è –∑–∞–±—Ä–∞—Ç—å –±–æ–ª—å—à–µ, —á–µ–º –µ—Å—Ç—å —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ({target_balance} ü¶é).")
            return

        new_balance = target_balance - amount_to_take
        await update_user_field(target_id, 'balance', new_balance)
        await message.answer(f"‚úÖ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ID {target_id} –±—ã–ª–æ –∏–∑—ä—è—Ç–æ {amount_to_take} ü¶é. –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} ü¶é.")

    except ValueError:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `take <user_id> <—Å—É–º–º–∞|all>`")
    except Exception as e:
        logger.error(f"Error in /take command: {e}")
        await message.answer("–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã.")

@dp.message(or_f(Command("givelevel", "–≤—ã–¥–∞—Ç—å—É—Ä–æ–≤–µ–Ω—å"), F.text.lower().startswith(('givelevel ', '–≤—ã–¥–∞—Ç—å—É—Ä–æ–≤–µ–Ω—å '))))
async def cmd_givelevel(message: Message, command: CommandObject = None):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return
    
    args = command.args if command else (message.text.split(maxsplit=1)[1] if ' ' in message.text else None)

    if not args:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∞—Ä–≥—É–º–µ–Ω—Ç—ã.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `givelevel <user_id> <level>`")
        return

    try:
        arg_parts = args.split()
        if len(arg_parts) != 2 or not arg_parts[1].isdigit(): raise ValueError
        target_id, level = int(arg_parts[0]), int(arg_parts[1])
        
        target_user = await get_user(target_id)
        if not target_user:
            await add_user(target_id, "Unknown by admin")
        
        await update_user_field(target_id, 'level', level)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ID {target_id} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω {level} —É—Ä–æ–≤–µ–Ω—å.")
    except ValueError:
        await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `givelevel <user_id> <—É—Ä–æ–≤–µ–Ω—å>`")
    except Exception as e:
        logger.error(f"Error in /givelevel command: {e}")
        await message.answer("–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã.")

@dp.message(or_f(Command("giveegg", "–≤—ã–¥–∞—Ç—å—è–π—Ü–æ"), F.text.lower().startswith(('giveegg ', '–≤—ã–¥–∞—Ç—å—è–π—Ü–æ '))))
async def cmd_giveegg(message: Message, command: CommandObject = None):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    args = command.args if command else (message.text.split(maxsplit=1)[1] if ' ' in message.text else None)

    if not args:
        await message.answer(f"‚ùóÔ∏è –û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∞—Ä–≥—É–º–µ–Ω—Ç—ã.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `giveegg <user_id> <type>`\n–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∏–ø—ã: {', '.join(EGGS.keys())}")
        return

    try:
        arg_parts = args.split()
        if len(arg_parts) != 2 or arg_parts[1] not in EGGS: raise ValueError
        target_id, egg_type = int(arg_parts[0]), arg_parts[1]

        target_user = await get_user(target_id)
        if not target_user:
            await add_user(target_id, "Unknown by admin")
        
        await add_user_egg(target_id, egg_type)
        await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ID {target_id} –≤—ã–¥–∞–Ω–æ —è–π—Ü–æ —Ç–∏–ø–∞ '{egg_type}'.")

    except ValueError:
        await message.answer(f"‚ùóÔ∏è –û—à–∏–±–∫–∞ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `giveegg <user_id> <type>`\n–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∏–ø—ã: {', '.join(EGGS.keys())}")
    except Exception as e:
        logger.error(f"Error in /giveegg command: {e}")
        await message.answer("–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã.")

# --- –°–ò–°–¢–ï–ú–ê –í–ò–ö–¢–û–†–ò–ù–´ ---
@dp.message(or_f(Command("quiz", "–≤–∏–∫—Ç–æ—Ä–∏–Ω–∞"), F.text.lower().in_(['quiz', '–≤–∏–∫—Ç–æ—Ä–∏–Ω–∞'])))
async def cmd_quiz(message: Message, state: FSMContext):
    await start_quiz_logic(message.from_user.id, message, state)

@dp.callback_query(F.data == "start_quiz")
async def cb_start_quiz(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await start_quiz_logic(callback.from_user.id, callback, state, is_callback=True)

async def start_quiz_logic(user_id: int, event: Message | CallbackQuery, state: FSMContext, is_callback: bool = False):
    user = await get_user(user_id)
    message = event if not is_callback else event.message
    
    if not user:
        await add_user(user_id, event.from_user.username or event.from_user.full_name)
        user = await get_user(user_id)

    now = int(datetime.now().timestamp())
    last_quiz = user['last_quiz'] or 0
    cooldown = QUIZ_COOLDOWN_HOURS * 3600

    if now - last_quiz < cooldown:
        remaining = cooldown - (now - last_quiz)
        hours, remainder = divmod(remaining, 3600)
        minutes, _ = divmod(remainder, 60)
        text = f"‚è≥ –í—ã —É–∂–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ –≤–∏–∫—Ç–æ—Ä–∏–Ω—É. –°–ª–µ–¥—É—é—â–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ {int(hours)} —á {int(minutes)} –º–∏–Ω."
        if is_callback:
            await event.answer(text, show_alert=True)
        else:
            await message.answer(text)
        return

    question_data = await get_random_question()
    if not question_data:
        text = "–í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞ –Ω–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã. –ó–∞–π–¥–∏—Ç–µ –ø–æ–∑–∂–µ!"
        if is_callback:
            await event.answer(text, show_alert=True)
        else:
            await message.answer(text)
        return
    
    await state.set_state(QuizStates.in_quiz)
    await state.update_data(question_id=question_data['question_id'], correct_answer=question_data['correct_answer'])

    options = json.loads(question_data['options'])
    random.shuffle(options)
    
    kb = InlineKeyboardBuilder()
    for option in options:
        kb.add(types.InlineKeyboardButton(text=option, callback_data=f"quiz_answer:{option}"))
    kb.adjust(1)
    
    text = f"üêç **–í–æ–ø—Ä–æ—Å –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã:**\n\n{question_data['question_text']}"
    try:
        if is_callback:
            await message.edit_text(text, reply_markup=kb.as_markup())
        else:
            await message.answer(text, reply_markup=kb.as_markup())
    except TelegramBadRequest:
        pass

@dp.callback_query(QuizStates.in_quiz, F.data.startswith("quiz_answer:"))
async def cb_process_quiz_answer(callback: CallbackQuery, state: FSMContext):
    user_answer = callback.data.split(":", 1)[1]
    quiz_data = await state.get_data()
    correct_answer = quiz_data.get('correct_answer')
    
    if not correct_answer:
        await callback.answer()
        return

    user = await get_user(callback.from_user.id)
    current_level = user['level'] or 0

    if user_answer == correct_answer:
        new_level = current_level + 1
        result_text = f"‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ!**\n\n–í–∞—à —É—Ä–æ–≤–µ–Ω—å –ø–æ–≤—ã—à–µ–Ω: {current_level} ‚û°Ô∏è {new_level}"
    else:
        new_level = max(0, current_level - 1)
        result_text = f"‚ùå **–ù–µ–≤–µ—Ä–Ω–æ!** –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correct_answer}\n\n–í–∞—à —É—Ä–æ–≤–µ–Ω—å –ø–æ–Ω–∏–∂–µ–Ω: {current_level} ‚û°Ô∏è {new_level}"

    await update_user_field(callback.from_user.id, 'level', new_level)
    await update_user_field(callback.from_user.id, 'last_quiz', int(datetime.now().timestamp()))
    await state.clear()
    
    await callback.message.edit_text(result_text, reply_markup=None)
    await callback.answer()

# --- –°–ò–°–¢–ï–ú–ê –ü–ò–¢–û–ú–¶–ï–í ---
@dp.message(or_f(Command("eggshop", "–º–∞–≥–∞–∑–∏–Ω—è–∏—Ü"), F.text.lower().in_(['eggshop', '–º–∞–≥–∞–∑–∏–Ω—è–∏—Ü'])))
async def cmd_eggshop(message: Message):
    text = "ü•ö **–ú–∞–≥–∞–∑–∏–Ω —è–∏—Ü** ü•ö\n\n–í—ã–±–µ—Ä–∏—Ç–µ —è–π—Ü–æ, —á—Ç–æ–±—ã –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –µ–≥–æ:"
    kb = InlineKeyboardBuilder()
    for egg_type, data in EGGS.items():
        kb.add(types.InlineKeyboardButton(text=f"{data['name']} ({data['cost']} ü¶é)", callback_data=f"buy_egg:{egg_type}"))
    kb.adjust(1)
    await message.answer(text, reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("buy_egg:"))
async def cb_buy_egg(callback: CallbackQuery):
    egg_type = callback.data.split(":")[1]
    egg_data = EGGS.get(egg_type)
    if not egg_data: return await callback.answer("–¢–∞–∫–æ–µ —è–π—Ü–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!", show_alert=True)
    
    user_id = callback.from_user.id
    user = await get_user(user_id)
    user_balance = user['balance'] or 0
    
    if user_balance < egg_data['cost']:
        return await callback.answer(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤! –ù—É–∂–Ω–æ {egg_data['cost']} ü¶é.", show_alert=True)
    
    await update_user_field(user_id, 'balance', user_balance - egg_data['cost'])
    await add_user_egg(user_id, egg_type)
    
    await callback.answer(f"–í—ã —É—Å–ø–µ—à–Ω–æ –∫—É–ø–∏–ª–∏ {egg_data['name']}!", show_alert=True)
    await callback.message.answer(f"üéâ –í—ã –ø—Ä–∏–æ–±—Ä–µ–ª–∏ {egg_data['name']}! –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ —è–π—Ü–∞ –∏ –≤—ã–ª—É–ø–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞ –º–æ–∂–Ω–æ –ø–æ –∫–æ–º–∞–Ω–¥–µ /myeggs –∏–ª–∏ –º–æ–∏—è–π—Ü–∞.")

@dp.message(or_f(Command("myeggs", "–º–æ–∏—è–π—Ü–∞"), F.text.lower().in_(['myeggs', '–º–æ–∏—è–π—Ü–∞'])))
async def cmd_myeggs(message: Message):
    user_id = message.from_user.id
    user_eggs = await get_user_eggs(user_id)
    
    if not user_eggs:
        return await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –∫—É–ø–ª–µ–Ω–Ω—ã—Ö —è–∏—Ü. –ó–∞–≥–ª—è–Ω–∏—Ç–µ –≤ /eggshop –∏–ª–∏ –º–∞–≥–∞–∑–∏–Ω —è–∏—Ü!")
        
    text = "üß∫ **–í–∞—à–∏ —è–π—Ü–∞** üß∫\n\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –≤—ã–ª—É–ø–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞:"
    kb = InlineKeyboardBuilder()
    for egg in user_eggs:
        egg_data = EGGS.get(egg['egg_type'])
        if egg_data:
            kb.add(types.InlineKeyboardButton(text=f"–í—ã–ª—É–ø–∏—Ç—å {egg_data['name']}", callback_data=f"hatch_egg:{egg['user_egg_id']}"))
    kb.adjust(1)
    await message.answer(text, reply_markup=kb.as_markup())
    
@dp.callback_query(F.data.startswith("hatch_egg:"))
async def cb_hatch_egg(callback: CallbackQuery, state: FSMContext):
    user_egg_id = int(callback.data.split(":")[1])
    user_id = callback.from_user.id
    
    user = await get_user(user_id)
    if (user['level'] or 0) < PET_MIN_LEVEL:
        return await callback.answer(f"–í—ã–ª—É–ø–ª—è—Ç—å –ø–∏—Ç–æ–º—Ü–µ–≤ –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —Å {PET_MIN_LEVEL} —É—Ä–æ–≤–Ω—è!", show_alert=True)
        
    pet = await get_pet(user_id)
    if pet:
        return await callback.answer("–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –ø–∏—Ç–æ–º–µ—Ü! –ù–µ–ª—å–∑—è –∑–∞–≤–µ—Å—Ç–∏ –≤—Ç–æ—Ä–æ–≥–æ.", show_alert=True)
        
    user_eggs = await get_user_eggs(user_id)
    target_egg = next((e for e in user_eggs if e['user_egg_id'] == user_egg_id), None)
    
    if not target_egg:
        await callback.message.edit_text("–≠—Ç–æ–≥–æ —è–π—Ü–∞ —É –≤–∞—Å –±–æ–ª—å—à–µ –Ω–µ—Ç.")
        return await callback.answer()
        
    await state.set_state(PetHatchStates.waiting_for_name)
    await state.update_data(user_egg_id=user_egg_id, egg_type=target_egg['egg_type'])
    
    await callback.message.edit_text("–û—Ç–ª–∏—á–Ω–æ! –ö–∞–∫ –≤—ã –Ω–∞–∑–æ–≤–µ—Ç–µ —Å–≤–æ–µ–≥–æ –Ω–æ–≤–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞? –í–≤–µ–¥–∏—Ç–µ –∏–º—è (–¥–æ 15 —Å–∏–º–≤–æ–ª–æ–≤).")
    await callback.answer()

@dp.message(PetHatchStates.waiting_for_name)
async def process_pet_name_after_hatch(message: Message, state: FSMContext):
    pet_name = message.text
    if len(pet_name) > 15:
        return await message.answer("–ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ (–¥–æ 15 —Å–∏–º–≤–æ–ª–æ–≤).")

    hatch_data = await state.get_data()
    user_egg_id = hatch_data['user_egg_id']
    egg_type = hatch_data['egg_type']
    
    egg_rarity = EGGS[egg_type]['rarity']
    possible_species = PET_SPECIES[egg_rarity]
    hatched_species_data = random.choice(possible_species)
    hatched_species_name = hatched_species_data['species_name']
    
    await delete_user_egg(user_egg_id)
    await create_pet(message.from_user.id, pet_name, hatched_species_name)
    await state.clear()
    
    await message.answer(f"üéâ –ò–∑ —è–π—Ü–∞ –≤—ã–ª—É–ø–∏–ª—Å—è **{hatched_species_name}**!\n–í—ã –Ω–∞–∑–≤–∞–ª–∏ –µ–≥–æ **{pet_name}**.\n\n–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ó–∞–±–æ—Ç—å—Ç–µ—Å—å –æ –Ω–µ–º —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /mypet –∏–ª–∏ –º–æ–π–ø–∏—Ç–æ–º–µ—Ü.")

@dp.message(or_f(Command("mypet", "–º–æ–π–ø–∏—Ç–æ–º–µ—Ü"), F.text.lower().in_(['mypet', '–º–æ–π–ø–∏—Ç–æ–º–µ—Ü'])))
async def cmd_mypet(message: Message):
    await my_pet_profile_logic(message.from_user.id, message)

@dp.callback_query(F.data == "my_pet_profile")
async def cb_mypet(callback: CallbackQuery):
    await my_pet_profile_logic(callback.from_user.id, callback, is_callback=True)

async def my_pet_profile_logic(user_id: int, event: Message | CallbackQuery, is_callback: bool = False):
    if is_callback:
        await event.answer()
    
    message = event if not is_callback else event.message
        
    if not await check_pet_death(user_id):
        if is_callback:
            try: await message.delete()
            except: pass
        return

    pet = await get_pet(user_id)
    if not pet:
        kb = InlineKeyboardBuilder().add(types.InlineKeyboardButton(text="ü•ö –í –º–∞–≥–∞–∑–∏–Ω —è–∏—Ü", callback_data="go_to_eggshop"))
        text = "–£ –≤–∞—Å –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ó–∞–≥–ª—è–Ω–∏—Ç–µ –≤ –º–∞–≥–∞–∑–∏–Ω —è–∏—Ü, —á—Ç–æ–±—ã –∑–∞–≤–µ—Å—Ç–∏ —Å–≤–æ–µ–≥–æ!"
        if is_callback and message.photo:
            await message.delete()
            await message.answer(text, reply_markup=kb.as_markup())
        elif is_callback:
            await message.edit_text(text, reply_markup=kb.as_markup())
        else:
            await message.answer(text, reply_markup=kb.as_markup())
        return

    now_ts = int(datetime.now().timestamp())
    pet_level = pet['pet_level']
    pet_species = pet['species']
    
    def format_time_since(timestamp):
        if not timestamp: return "–Ω–∏–∫–æ–≥–¥–∞"
        dt_obj = datetime.fromtimestamp(timestamp)
        return dt_obj.strftime('%d.%m %H:%M')

    caption = (
        f"üêæ **–ü–∏—Ç–æ–º–µ—Ü: {pet['name']}** ({pet_species})\n\n"
        f"–£—Ä–æ–≤–µ–Ω—å: {pet_level}\n"
        f"–ö–æ—Ä–º: {format_time_since(pet['last_fed'])}\n"
    )
    if pet_level >= 10:
        caption += f"–í–æ–¥–∞: {format_time_since(pet['last_watered'])}\n"
    if pet_level >= 15:
        caption += f"–ü—Ä–æ–≥—É–ª–∫–∞: {format_time_since(pet['last_walked'])}\n"

    kb = InlineKeyboardBuilder()
    kb.add(types.InlineKeyboardButton(text=f"–ü–æ–∫–æ—Ä–º–∏—Ç—å ({PET_ACTIONS_COST['feed']}ü¶é)", callback_data="pet_action:feed"))
    
    grow_cooldown_ok = now_ts - (pet['last_grown'] or 0) > 24 * 3600
    grow_btn_text = f"–†–∞—Å—Ç–∏—Ç—å ({PET_ACTIONS_COST['grow']}ü¶é)" if grow_cooldown_ok else "–†–∞—Å—Ç–∏—Ç—å (–ö–î)"
    kb.add(types.InlineKeyboardButton(text=grow_btn_text, callback_data="pet_action:grow"))

    if pet_level >= 10:
        kb.add(types.InlineKeyboardButton(text=f"–ü–æ–∏—Ç—å ({PET_ACTIONS_COST['water']}ü¶é)", callback_data="pet_action:water"))
    if pet_level >= 15:
        kb.add(types.InlineKeyboardButton(text=f"–í—ã–≥—É–ª–∏–≤–∞—Ç—å ({PET_ACTIONS_COST['walk']}ü¶é)", callback_data="pet_action:walk"))
    
    kb.adjust(2)

    image_url = "https://i.imgur.com/3TSa7A0.png"
    species_data = next((s for rarity in PET_SPECIES.values() for s in rarity if s['species_name'] == pet_species), None)
    if species_data:
        for level_threshold, url in sorted(species_data['images'].items(), reverse=True):
            if pet_level >= level_threshold:
                image_url = url
                break
    
    try:
        if is_callback:
            media = types.InputMediaPhoto(media=image_url, caption=caption)
            await message.edit_media(media=media, reply_markup=kb.as_markup())
        else:
            await bot.send_photo(user_id, photo=image_url, caption=caption, reply_markup=kb.as_markup())
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
            if is_callback: await event.answer("–î–∞–Ω–Ω—ã–µ –ø–∏—Ç–æ–º—Ü–∞ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å.")
        else:
            logger.error(f"Failed to edit pet profile, sending new: {e}")
            await bot.send_photo(user_id, photo=image_url, caption=caption, reply_markup=kb.as_markup())

@dp.callback_query(F.data == "go_to_eggshop")
async def cb_go_to_eggshop(callback: CallbackQuery):
    await callback.message.delete()
    await cmd_eggshop(callback.message)
    await callback.answer()

@dp.callback_query(F.data.startswith("pet_action:"))
async def cb_pet_action(callback: CallbackQuery):
    action = callback.data.split(":")[1]
    user_id = callback.from_user.id
    
    if not await check_pet_death(user_id):
        try: await callback.message.delete()
        except: pass
        await callback.answer("–í–∞—à –ø–∏—Ç–æ–º–µ—Ü —É–º–µ—Ä...", show_alert=True)
        return

    pet = await get_pet(user_id)
    user = await get_user(user_id)
    cost = PET_ACTIONS_COST.get(action, 0)
    
    user_balance = user['balance'] or 0
    if user_balance < cost:
        await callback.answer(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —è—â–µ—Ä–æ–∫! –ù—É–∂–Ω–æ {cost} ü¶é.", show_alert=True)
        return

    now = int(datetime.now().timestamp())
    
    result_text = ""
    if action == "grow":
        if now - (pet['last_grown'] or 0) < 24 * 3600:
            await callback.answer("–†–∞—Å—Ç–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞ –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —Ä–∞–∑ –≤ –¥–µ–Ω—å!", show_alert=True)
            return
        await db_execute("UPDATE pets SET pet_level = ?, last_grown = ? WHERE owner_id = ?", (pet['pet_level'] + 1, now, user_id))
        result_text = f"–í—ã –≤—ã—Ä–∞—Å—Ç–∏–ª–∏ —Å–≤–æ–µ–≥–æ –ø–∏—Ç–æ–º—Ü–∞! –ï–≥–æ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å: {pet['pet_level'] + 1}."
    elif action == "feed":
        await update_pet_field(user_id, "last_fed", now)
        result_text = "–í—ã –ø–æ–∫–æ—Ä–º–∏–ª–∏ –ø–∏—Ç–æ–º—Ü–∞."
    elif action == "water":
        if pet['pet_level'] < 10:
            await callback.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Å 10 —É—Ä–æ–≤–Ω—è –ø–∏—Ç–æ–º—Ü–∞!", show_alert=True)
            return
        await update_pet_field(user_id, "last_watered", now)
        result_text = "–í—ã –Ω–∞–ø–æ–∏–ª–∏ –ø–∏—Ç–æ–º—Ü–∞."
    elif action == "walk":
        if pet['pet_level'] < 15:
            await callback.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Å 15 —É—Ä–æ–≤–Ω—è –ø–∏—Ç–æ–º—Ü–∞!", show_alert=True)
            return
        await update_pet_field(user_id, "last_walked", now)
        result_text = "–í—ã –≤—ã–≥—É–ª—è–ª–∏ –ø–∏—Ç–æ–º—Ü–∞."
    else:
        return

    await update_user_field(user_id, "balance", user_balance - cost)
    await callback.answer(result_text, show_alert=False)
    await my_pet_profile_logic(user_id, callback, is_callback=True)

# --- –°–ò–°–¢–ï–ú–ê –ú–ê–ì–ê–ó–ò–ù–ê ---
SHOP_ITEMS = {"prefix": {"name": "–ü—Ä–µ—Ñ–∏–∫—Å", "prices": {1: 20, 3: 40, 7: 100}}, "antitar": {"name": "–ê–Ω—Ç–∏—Ç–∞—Ä", "prices": {1: 30, 3: 60, 7: 130}}, "vip": {"name": "VIP", "prices": {1: 50, 3: 100, 7: 300}}}

def create_shop_menu():
    kb = InlineKeyboardBuilder()
    for item_id, item_data in SHOP_ITEMS.items():
        kb.add(types.InlineKeyboardButton(text=item_data["name"], callback_data=f"shop_item:{item_id}"))
    kb.adjust(1)
    return kb.as_markup()

def create_item_menu(item_id: str):
    kb = InlineKeyboardBuilder()
    item_data = SHOP_ITEMS[item_id]
    for days, price in item_data["prices"].items():
        kb.add(types.InlineKeyboardButton(text=f"{days} –¥–Ω. - {price} ü¶é", callback_data=f"buy:{item_id}:{days}"))
    kb.add(types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="shop_main"))
    kb.adjust(1)
    return kb.as_markup()

@dp.message(or_f(Command("shop", "–º–∞–≥–∞–∑–∏–Ω"), F.text.lower().in_(['shop', '–º–∞–≥–∞–∑–∏–Ω'])))
async def cmd_shop(message: Message):
    await message.answer("üõí –ú–∞–≥–∞–∑–∏–Ω: –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –ø–æ–∫—É–ø–∫–∏.", reply_markup=create_shop_menu())

@dp.callback_query(F.data == "shop_main")
async def cb_shop_main(callback: CallbackQuery):
    await callback.message.edit_text("üõí –ú–∞–≥–∞–∑–∏–Ω: –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –ø–æ–∫—É–ø–∫–∏.", reply_markup=create_shop_menu())
    await callback.answer()

@dp.callback_query(F.data.startswith("shop_item:"))
async def cb_shop_item(callback: CallbackQuery):
    item_id = callback.data.split(":")[1]
    item_name = SHOP_ITEMS[item_id]["name"]
    await callback.message.edit_text(f"–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ —Ç–æ–≤–∞—Ä–∞ ¬´{item_name}¬ª:", reply_markup=create_item_menu(item_id))
    await callback.answer()

@dp.callback_query(F.data.startswith("buy:"))
async def cb_buy_item(callback: CallbackQuery):
    try:
        _, item_id, days_str = callback.data.split(":")
        days = int(days_str)
        user_id = callback.from_user.id
        item_data = SHOP_ITEMS.get(item_id)
        if not item_data:
            return await callback.answer("–û—à–∏–±–∫–∞: —Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        price = item_data["prices"].get(days)
        item_name = item_data["name"]
        if price is None:
            return await callback.answer("–û—à–∏–±–∫–∞: —Ü–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
        user = await get_user(user_id)
        if not user:
            return await callback.answer("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–ø–∏—à–∏—Ç–µ /start", show_alert=True)
        
        user_balance = user["balance"] or 0
        if user_balance < price:
            await callback.answer(f"‚ùå –£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ ü¶é (—É –≤–∞—Å {user_balance}, —Ç—Ä–µ–±—É–µ—Ç—Å—è {price}).", show_alert=True)
            return
        
        new_balance = user_balance - price
        await update_user_field(user_id, "balance", new_balance)
        now_ts = int(datetime.now().timestamp())
        add_seconds = days * 24 * 3600
        field_name = f"{item_id}_end"
        current_end = user[field_name] or 0
        new_end = max(current_end, now_ts) + add_seconds
        await update_user_field(user_id, field_name, new_end)
        await callback.message.edit_text(f"‚úÖ –ü–æ–∫—É–ø–∫–∞ —É—Å–ø–µ—à–Ω–∞! –í—ã –ø—Ä–∏–æ–±—Ä–µ–ª–∏ ¬´{item_name}¬ª.\n–í–∞—à –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} ü¶é")
        await callback.answer()
    except Exception as e:
        logger.exception(f"Error in buy handler: {e}")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ.", show_alert=True)

# --- –°–ò–°–¢–ï–ú–ê –ü–û–ü–û–õ–ù–ï–ù–ò–Ø –ß–ï–†–ï–ó TELEGRAM STARS ---
@dp.message(or_f(Command("topup", "–ø–æ–ø–æ–ª–Ω–∏—Ç—å"), F.text.lower().in_(['topup', '–ø–æ–ø–æ–ª–Ω–∏—Ç—å'])))
async def cmd_topup(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —è—â–µ—Ä–æ–∫, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∫—É–ø–∏—Ç—å.\n\n‚ñ´Ô∏è **–ö—É—Ä—Å:** 3 —è—â–µ—Ä–∫–∏ = 1 ‚òÖ\n‚ñ´Ô∏è **–õ–∏–º–∏—Ç—ã:** –æ—Ç 20 –¥–æ 10 000 —è—â–µ—Ä–æ–∫ –∑–∞ —Ä–∞–∑.\n‚ñ´Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–æ 3.\n\n–î–ª—è –æ—Ç–º–µ–Ω—ã –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ /cancel –∏–ª–∏ –æ—Ç–º–µ–Ω–∞.")
    await state.set_state(TopupStates.waiting_for_amount)

@dp.message(or_f(Command("cancel", "–æ—Ç–º–µ–Ω–∞"), F.text.lower().in_(['cancel', '–æ—Ç–º–µ–Ω–∞'])), F.state == TopupStates.waiting_for_amount)
async def cancel_topup(message: Message, state: FSMContext):
    await message.answer("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await state.clear()

@dp.message(TopupStates.waiting_for_amount)
async def process_topup_amount(message: Message, state: FSMContext):
    try:
        lizards_to_buy = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.")
    if not (20 <= lizards_to_buy <= 10000):
        return await message.answer("‚ùå –í—ã –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å –æ—Ç 20 –¥–æ 10 000 —è—â–µ—Ä–æ–∫ –∑–∞ —Ä–∞–∑.")
    if lizards_to_buy % 3 != 0:
        lower = (lizards_to_buy // 3) * 3
        upper = lower + 3
        return await message.answer(f"‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —è—â–µ—Ä–æ–∫ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–æ 3.\n\n–í—ã –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, {lower if lower >= 20 else upper} –∏–ª–∏ {upper} ü¶é.")
    stars_price = lizards_to_buy // 3
    await state.clear()
    await bot.send_invoice(chat_id=message.from_user.id, title=f"–ü–æ–∫—É–ø–∫–∞ {lizards_to_buy} ü¶é", description=f"–ü–∞–∫–µ—Ç –∏–∑ {lizards_to_buy} —è—â–µ—Ä–æ–∫ –¥–ª—è –≤–∞—à–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –≤ –±–æ—Ç–µ.", payload=f"lizard_topup:{message.from_user.id}:{lizards_to_buy}", currency="XTR", prices=[LabeledPrice(label=f"{lizards_to_buy} ü¶é", amount=stars_price)])

@dp.pre_checkout_query()
async def pre_checkout_query_handler(pre_checkout_query: PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@dp.message(F.successful_payment)
async def successful_payment_handler(message: Message):
    try:
        payload = message.successful_payment.invoice_payload
        _, user_id_str, lizards_str = payload.split(":")
        user_id = int(user_id_str)
        lizards_to_add = int(lizards_str)
        await add_user(user_id, message.from_user.username or message.from_user.full_name)
        user = await get_user(user_id)
        current_balance = user['balance'] or 0
        new_balance = current_balance + lizards_to_add
        await update_user_field(user_id, 'balance', new_balance)
        await bot.send_message(chat_id=user_id, text=f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!\n\n–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ: {lizards_to_add} ü¶é\n–í–∞—à –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance} ÔøΩ")
    except Exception as e:
        logger.error(f"Error in successful_payment_handler: {e}")
        await bot.send_message(chat_id=message.from_user.id, text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ —è—â–µ—Ä–æ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")

# --- –°–ò–°–¢–ï–ú–ê –ë–†–ê–ö–û–í ---
@dp.message(or_f(Command("marry", "–∂–µ–Ω–∏—Ç—å"), F.text.lower().in_(['marry', '–∂–µ–Ω–∏—Ç—å'])))
async def cmd_marry(message: Message):
    if message.chat.type == 'private':
        await message.answer("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –≥—Ä—É–ø–ø–µ, –æ—Ç–≤–µ—á–∞—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return

    if not message.reply_to_message or message.reply_to_message.from_user.is_bot or message.reply_to_message.from_user.id == message.from_user.id:
        return await message.reply("–ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç—É –∫–æ–º–∞–Ω–¥—É –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        
    proposer = message.from_user
    target = message.reply_to_message.from_user

    await add_user(proposer.id, proposer.username or proposer.full_name)
    await add_user(target.id, target.username or target.full_name)
    proposer_data = await get_user(proposer.id)
    target_data = await get_user(target.id)
    
    if (proposer_data['level'] or 0) < MARRIAGE_MIN_LEVEL:
        return await message.reply(f"‚ùå –î–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –±—Ä–∞–∫ –Ω—É–∂–µ–Ω {MARRIAGE_MIN_LEVEL} —É—Ä–æ–≤–µ–Ω—å. –í–∞—à —É—Ä–æ–≤–µ–Ω—å: {proposer_data['level'] or 0}.")
    if (target_data['level'] or 0) < MARRIAGE_MIN_LEVEL:
        return await message.reply(f"‚ùå –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target.full_name} –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –¥–ª—è –±—Ä–∞–∫–∞ ({target_data['level'] or 0}/{MARRIAGE_MIN_LEVEL}).")
    
    if proposer_data['partner_id']:
        return await message.reply("–í—ã —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö.")
    if (proposer_data['balance'] or 0) < MARRIAGE_COST:
        return await message.reply(f"‚ùå –î–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –Ω—É–∂–Ω–æ {MARRIAGE_COST} ü¶é.\n–£ –≤–∞—Å –Ω–∞ –±–∞–ª–∞–Ω—Å–µ: {proposer_data['balance'] or 0} ü¶é.")
    if target_data['partner_id']:
        return await message.reply(f"{target.full_name} —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö.")
    if target_data['proposal_from_id']:
        return await message.reply(f"–£ {target.full_name} —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ. –î–æ–∂–¥–∏—Ç–µ—Å—å –æ—Ç–≤–µ—Ç–∞.")

    kb = InlineKeyboardBuilder()
    kb.add(types.InlineKeyboardButton(text="–î–∞, —è —É–≤–µ—Ä–µ–Ω", callback_data=f"marry_confirm:{proposer.id}:{target.id}"))
    kb.add(types.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞", callback_data="marry_cancel"))
    target_mention = await get_user_mention_by_id(target.id)
    await message.reply(f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {target_mention}?\n–°—Ç–æ–∏–º–æ—Å—Ç—å —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è: {MARRIAGE_COST} ü¶é.\n\n–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –±—É–¥–µ—Ç –æ—Ç–º–µ–Ω–∏—Ç—å.", reply_markup=kb.as_markup(), parse_mode="HTML")

@dp.message(or_f(Command("accept", "–ø—Ä–∏–Ω—è—Ç—å"), F.text.lower().in_(['accept', '–ø—Ä–∏–Ω—è—Ç—å'])))
async def cmd_accept(message: Message):
    user_id = message.from_user.id
    await add_user(user_id, message.from_user.username or message.from_user.full_name)
    user_data = await get_user(user_id)
    if not user_data['proposal_from_id']:
        return await message.reply("–í–∞–º –Ω–∏–∫—Ç–æ –Ω–µ –¥–µ–ª–∞–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π.")
    proposer_id = user_data['proposal_from_id']
    proposer_data = await get_user(proposer_id)
    if not proposer_data or proposer_data['partner_id']:
        await message.reply("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return await update_user_field(user_id, "proposal_from_id", 0)
        
    await update_user_field(user_id, "partner_id", proposer_id)
    await update_user_field(proposer_id, "partner_id", user_id)
    await update_user_field(user_id, "proposal_from_id", 0)
    user_mention = await get_user_mention_by_id(user_id)
    proposer_mention = await get_user_mention_by_id(proposer_id)
    await message.answer(f"üíñ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! {proposer_mention} –∏ {user_mention} —Ç–µ–ø–µ—Ä—å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ —Å–æ—Å—Ç–æ—è—Ç –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö! üíñ", parse_mode="HTML")

@dp.message(or_f(Command("divorce", "—Ä–∞–∑–≤–æ–¥"), F.text.lower().in_(['divorce', '—Ä–∞–∑–≤–æ–¥'])))
async def cmd_divorce(message: Message):
    user_id = message.from_user.id
    await add_user(user_id, message.from_user.username or message.from_user.full_name)
    user_data = await get_user(user_id)
    if not user_data['partner_id']:
        return await message.reply("–í—ã –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö, –Ω–µ–∫–æ–≥–æ –±—Ä–æ—Å–∞—Ç—å.")
    kb = InlineKeyboardBuilder()
    kb.add(types.InlineKeyboardButton(text="–î–∞, —è —Ö–æ—á—É —Ä–∞–∑–≤–µ—Å—Ç–∏—Å—å", callback_data="confirm_divorce"))
    kb.add(types.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞", callback_data="cancel_divorce"))
    await message.reply("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Ä–≤–∞—Ç—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("marry_confirm:"))
async def confirm_marry(callback: CallbackQuery):
    _, proposer_id_str, target_id_str = callback.data.split(":")
    proposer_id = int(proposer_id_str)
    if callback.from_user.id != proposer_id:
        return await callback.answer("–≠—Ç–æ –Ω–µ –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ!", show_alert=True)
    target_id = int(target_id_str)
    proposer_data = await get_user(proposer_id)
    target_data = await get_user(target_id)
    if not proposer_data or not target_data:
        await callback.message.edit_text("–û—à–∏–±–∫–∞: –æ–¥–∏–Ω –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return await callback.answer()
    if (proposer_data['balance'] or 0) < MARRIAGE_COST:
        await callback.message.edit_text(f"‚ùå –£–ø—Å! –ù–∞ –≤–∞—à–µ–º —Å—á–µ—Ç—É –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤. –¢—Ä–µ–±—É–µ—Ç—Å—è {MARRIAGE_COST} ü¶é.")
        return await callback.answer()
    if target_data['partner_id'] or target_data['proposal_from_id']:
        await callback.message.edit_text("‚ùå –£–ø—Å! –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø–æ–ª—É—á–∏–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ –≤—Å—Ç—É–ø–∏–ª –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è.")
        return await callback.answer()
    try:
        new_balance = (proposer_data['balance'] or 0) - MARRIAGE_COST
        await update_user_field(proposer_id, "balance", new_balance)
        await update_user_field(target_id, "proposal_from_id", proposer_id)
        proposer_mention = await get_user_mention_by_id(proposer_id)
        target_mention = await get_user_mention_by_id(target_id)
        await callback.message.edit_text("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!")
        await callback.message.answer(f"üíç {target_mention}, –≤–∞–º –ø–æ—Å—Ç—É–ø–∏–ª–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ä—É–∫–∏ –∏ —Å–µ—Ä–¥—Ü–∞ –æ—Ç {proposer_mention}!\n\n–ß—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å –µ–≥–æ, –Ω–∞–ø–∏—à–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É `/accept` –∏–ª–∏ `–ø—Ä–∏–Ω—è—Ç—å`.", parse_mode="HTML")
        await callback.answer()
    except Exception as e:
        logger.error(f"Error during marriage confirmation: {e}")
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        await callback.answer()

@dp.callback_query(F.data == "marry_cancel")
async def cancel_marry(callback: CallbackQuery):
    await callback.message.edit_text("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await callback.answer()

@dp.callback_query(F.data == "confirm_divorce")
async def confirm_divorce(callback: CallbackQuery):
    user_id = callback.from_user.id
    user_data = await get_user(user_id)
    if not user_data or not user_data['partner_id']:
        await callback.message.edit_text("–í—ã –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö.")
        return await callback.answer()
    partner_id = user_data['partner_id']
    await update_user_field(user_id, "partner_id", 0)
    await update_user_field(partner_id, "partner_id", 0)
    user_mention = await get_user_mention_by_id(user_id)
    partner_mention = await get_user_mention_by_id(partner_id)
    await callback.message.edit_text("–û—Ç–Ω–æ—à–µ–Ω–∏—è —Ä–∞–∑–æ—Ä–≤–∞–Ω—ã.")
    await callback.message.answer(f"üíî {user_mention} –∏ {partner_mention} –±–æ–ª—å—à–µ –Ω–µ –≤–º–µ—Å—Ç–µ. üíî", parse_mode="HTML")
    await callback.answer()

@dp.callback_query(F.data == "cancel_divorce")
async def cancel_divorce(callback: CallbackQuery):
    await callback.message.edit_text("–†–∞–∑–≤–æ–¥ –æ—Ç–º–µ–Ω–µ–Ω. –í–∞—à–∏ –æ—Ç–Ω–æ—à–µ–Ω–∏—è –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏!")
    await callback.answer()

@dp.message(or_f(Command("ping", "–ø–∏–Ω–≥"), F.text.lower().in_(['ping', '–ø–∏–Ω–≥'])))
async def cmd_ping(message: Message):
    """–ü–∏–Ω–≥—É–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç–µ."""
    if message.chat.type not in {'group', 'supergroup'}:
        await message.reply("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö.")
        return

    chat_id = message.chat.id
    pinger_id = message.from_user.id

    if chat_id not in recent_users_activity or len(recent_users_activity[chat_id]) <= 1:
        await message.reply("–Ø –µ—â–µ –Ω–µ –≤–∏–¥–µ–ª –∑–¥–µ—Å—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏, –Ω–µ–∫–æ–≥–æ –ø–∏–Ω–≥–æ–≤–∞—Ç—å.")
        return

    now = datetime.now().timestamp()
    active_users_ids = [
        uid for uid, last_seen in recent_users_activity[chat_id].items()
        if (now - last_seen) < 86400 and uid != pinger_id
    ]

    if not active_users_ids:
        await message.reply("–ö—Ä–æ–º–µ –≤–∞—Å –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –Ω–∏–∫—Ç–æ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏—á–∞–ª.")
        return

    target_id = random.choice(active_users_ids)
    try:
        target_mention = await get_user_mention_by_id(target_id)
        pinger_mention = await get_user_mention_by_id(pinger_id)
        ping_text = random.choice(PING_MESSAGES)

        await message.answer(f"üìû {target_mention}, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {pinger_mention} —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: ¬´{ping_text}¬ª", parse_mode="HTML")
    except Exception as e:
        logger.error(f"Error in ping command while getting user mentions: {e}")
        await message.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–±—Ä–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–∏–Ω–≥–∞.")

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –ê–ö–¢–ò–í–ù–û–°–¢–ò (–î–õ–Ø –ö–û–ú–ê–ù–î–´ /PING)---
@dp.message()
async def track_user_activity(message: types.Message):
    """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –≥—Ä—É–ø–ø–∞—Ö –¥–ª—è —Ä–∞–±–æ—Ç—ã /ping."""
    if message.chat.type in {'group', 'supergroup'}:
        if not message.from_user.is_bot:
            recent_users_activity.setdefault(message.chat.id, {})
            recent_users_activity[message.chat.id][message.from_user.id] = datetime.now().timestamp()

# --- –ó–ê–ü–£–°–ö –ë–û–¢–ê ---
async def main():
    await init_db()
    await populate_questions()
    bot.default_parse_mode = "HTML"
    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())
